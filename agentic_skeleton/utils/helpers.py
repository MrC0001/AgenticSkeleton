"""
Utility Functions
================

Provides helper functions for the application including:
- Terminal output formatting
- Text processing
- Mock response generation
- Azure OpenAI integration
"""

import sys
import logging
import random
import re
import subprocess
from typing import Dict, List, Any, Optional, Tuple, Union

# Try to import termcolor for colored terminal output
try:
    from termcolor import colored
except ImportError:
    # Define a dummy colored function if termcolor is not installed
    def colored(text, *args, **kwargs):
        return text

def ensure_termcolor_installed():
    """
    Check if termcolor is installed and install it if not.
    
    Returns:
        None
    """
    try:
        # Define dummy function for comparison
        dummy_colored = lambda text, *args, **kwargs: text
        
        # Check if our colored function is the dummy one
        if 'colored' in globals() and colored.__code__.co_code == dummy_colored.__code__.co_code:
            print("Installing termcolor for better output formatting...")
            subprocess.run(
                [sys.executable, "-m", "pip", "install", "termcolor"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            # Re-import termcolor after installation
            globals()['colored'] = __import__('termcolor').colored
    except Exception:
        # If installation fails, continue with dummy function
        pass

def setup_logging():
    """
    Configure logging for the application with colored output.
    
    Returns:
        None
    """
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        stream=sys.stdout
    )
    
    # Enhance logging with colored output
    original_factory = logging.getLogRecordFactory()
    
    def colored_record_factory(*args, **kwargs):
        record = original_factory(*args, **kwargs)
        
        # Add color based on log level
        levelname = record.levelname
        if levelname == 'DEBUG':
            record.levelname = colored(levelname, 'cyan')
        elif levelname == 'INFO':
            record.levelname = colored(levelname, 'green')
        elif levelname == 'WARNING':
            record.levelname = colored(levelname, 'yellow')
        elif levelname == 'ERROR':
            record.levelname = colored(levelname, 'red')
        elif levelname == 'CRITICAL':
            record.levelname = colored(levelname, 'red', attrs=['bold'])
            
        return record
        
    logging.setLogRecordFactory(colored_record_factory)
    
    return logging

def extract_subtasks_from_text(text: str) -> List[str]:
    """
    Extract numbered subtasks from text generated by a language model.
    
    Args:
        text: The text containing numbered subtasks
        
    Returns:
        List of extracted subtasks
    """
    # Extract numbered list items from the text
    subtasks = []
    lines = text.splitlines()
    
    for line in lines:
        line = line.strip()
        # Match lines that start with a number followed by period or parenthesis
        if re.match(r'^\d+[\.\)]', line):
            # Extract the text after the number and delimiter
            task_text = re.sub(r'^\d+[\.\)]\s*', '', line).strip()
            if task_text:
                subtasks.append(task_text)
    
    return subtasks

def format_terminal_header(app_name: str, use_mock: bool):
    """
    Format a nice header for terminal output.
    
    Args:
        app_name: The name of the application
        use_mock: Whether the app is using mock mode
        
    Returns:
        None (prints to terminal)
    """
    border = colored("=" * 69, "blue")
    print(border)
    
    # Show the app header with mode info
    title = colored(f"ðŸ¤– {app_name}", "cyan", attrs=["bold"])
    mode = colored("MOCK", "yellow", attrs=["bold"]) if use_mock else colored("AZURE", "green", attrs=["bold"])
    print(f"{title} - Running in {mode} mode")